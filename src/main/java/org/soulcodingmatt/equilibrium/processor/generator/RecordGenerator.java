package org.soulcodingmatt.equilibrium.processor.generator;

import org.soulcodingmatt.equilibrium.annotations.common.IgnoreAll;
import org.soulcodingmatt.equilibrium.annotations.record.IgnoreRecord;

import javax.annotation.processing.Filer;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.io.Writer;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class RecordGenerator {
    private final TypeElement classElement;
    private final String packageName;
    private final String postfix;
    private final Filer filer;

    public RecordGenerator(TypeElement classElement, String packageName, String postfix,
                       Filer filer) {
        this.classElement = classElement;
        this.packageName = packageName;
        this.postfix = postfix;
        this.filer = filer;
    }

    public void generate() throws IOException {
        String className = classElement.getSimpleName().toString();
        String recordClassName = className + postfix;
        
        // Get all fields that should be included in the Record
        List<VariableElement> fields = getIncludedFields();
        
        // Create or update the Record file
        JavaFileObject sourceFile = filer.createSourceFile(packageName + "." + recordClassName, classElement);
        
        try (Writer writer = sourceFile.openWriter()) {
            // Write package declaration
            writer.write("package " + packageName + ";\n\n");
            
            // Write imports
            writeImports(writer, fields);
            
            // Write record declaration
            writer.write("/**\n");
            writer.write(" * Record for {@link " + classElement.getQualifiedName() + "}\n");
            writer.write(" * Generated by Equilibrium\n");
            writer.write(" */\n");
            
            // Write record with its parameters
            writer.write("public record " + recordClassName + "(");
            writeRecordParameters(writer, fields);
            writer.write(") {}\n");
        }
    }

    private List<VariableElement> getIncludedFields() {
        return classElement.getEnclosedElements().stream()
            .filter(element -> element.getKind() == ElementKind.FIELD)
            .map(VariableElement.class::cast)
            .filter(this::shouldIncludeField)
            .toList();
    }

    private boolean shouldIncludeField(VariableElement field) {
        // Exclude fields marked with @IgnoreRecord or @IgnoreAll
        if (field.getAnnotation(IgnoreRecord.class) != null ||
            field.getAnnotation(IgnoreAll.class) != null) {
            return false;
        }
        
        // Exclude static and transient fields
        Set<Modifier> modifiers = field.getModifiers();
        return !modifiers.contains(Modifier.STATIC) && 
               !modifiers.contains(Modifier.TRANSIENT);
    }

    private void writeImports(Writer writer, List<VariableElement> fields) throws IOException {
        Set<String> imports = fields.stream()
            .map(field -> field.asType().toString())
            .map(this::extractBaseType)
            .filter(type -> type.contains("."))
            .collect(Collectors.toSet());
        
        for (String importType : imports) {
            writer.write("import " + importType + ";\n");
        }
        writer.write("\n");
    }

    private String extractBaseType(String fullType) {
        // Remove generic type parameters for import statements
        int genericStart = fullType.indexOf('<');
        if (genericStart > 0) {
            return fullType.substring(0, genericStart);
        }
        return fullType;
    }

    private void writeRecordParameters(Writer writer, List<VariableElement> fields) throws IOException {
        boolean first = true;
        for (VariableElement field : fields) {
            if (!first) {
                writer.write(", ");
            }
            String type = field.asType().toString();
            String name = field.getSimpleName().toString();
            writer.write(type + " " + name);
            first = false;
        }
    }
}
