package io.github.soulcodingmatt.equilibrium.processor.generator;

import io.github.soulcodingmatt.equilibrium.annotations.common.IgnoreAll;
import io.github.soulcodingmatt.equilibrium.annotations.dto.IgnoreDto;

import javax.annotation.processing.Filer;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.type.TypeKind;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.io.Writer;
import java.util.List;
import java.util.Set;
import java.util.HashSet;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class DtoGenerator {
    private final TypeElement classElement;
    private final String packageName;
    private final String postfix;
    private final Set<String> ignoredFields;
    private final boolean builder;
    private final Filer filer;

    public DtoGenerator(TypeElement classElement, String packageName, String postfix,
                        Set<String> ignoredFields, boolean builder, Filer filer) {
        this.classElement = classElement;
        this.packageName = packageName;
        this.postfix = postfix;
        this.ignoredFields = ignoredFields != null ? ignoredFields : new HashSet<>();
        this.filer = filer;
        this.builder = builder;
    }

    public void generate() throws IOException {
        String className = classElement.getSimpleName().toString();
        String dtoClassName = className + postfix;
        
        // Get all fields that should be included in the DTO
        List<VariableElement> fields = getIncludedFields();
        
        // Create or update the DTO file
        JavaFileObject sourceFile = filer.createSourceFile(packageName + "." + dtoClassName, classElement);
        
        try (Writer writer = sourceFile.openWriter()) {
            // Write package declaration
            writer.write("package " + packageName + ";\n\n");
            
            // Write imports
            if (builder) {
                writer.write("import lombok.experimental.SuperBuilder;\n");
            }
            writeImports(writer, fields);
            
            // Write class declaration
            writer.write("/**\n");
            writer.write(" * DTO for {@link " + classElement.getQualifiedName() + "}\n");
            writer.write(" * Generated by Equilibrium\n");
            writer.write(" */\n");
            if (builder) {
                writer.write("@SuperBuilder\n");
            }
            writer.write("public class " + dtoClassName + " {\n\n");
            
            // Write fields
            for (VariableElement field : fields) {
                writeField(writer, field);
            }
            
            // Write getters and setters
            for (VariableElement field : fields) {
                writeAccessors(writer, field);
            }
            
            // Close class
            writer.write("}\n");
        }
    }

    private List<VariableElement> getIncludedFields() {
        return collectFieldsFromHierarchy(classElement);
    }

    private List<VariableElement> collectFieldsFromHierarchy(TypeElement element) {
        List<VariableElement> fields = element.getEnclosedElements().stream()
            .filter(e -> e.getKind() == ElementKind.FIELD)
            .map(VariableElement.class::cast)
            .filter(this::shouldIncludeField)
            .toList();

        // Get parent class fields
        TypeMirror superclass = element.getSuperclass();
        if (superclass.getKind() != TypeKind.NONE && !superclass.toString().equals("java.lang.Object")) {
            TypeElement superclassElement = (TypeElement) ((DeclaredType) superclass).asElement();
            fields = Stream.concat(
                fields.stream(),
                collectFieldsFromHierarchy(superclassElement).stream()
            ).toList();
        }

        return fields;
    }

    private boolean shouldIncludeField(VariableElement field) {
        // Exclude fields marked with @IgnoreDto or @IgnoreAll
        if (field.getAnnotation(IgnoreDto.class) != null ||
            field.getAnnotation(IgnoreAll.class) != null) {
            return false;
        }
        
        // Exclude any fields specified in the ignore collection
        String fieldName = field.getSimpleName().toString();
        if (ignoredFields.contains(fieldName)) {
            return false;
        }
        
        // Exclude static and transient fields
        Set<Modifier> modifiers = field.getModifiers();
        return !modifiers.contains(Modifier.STATIC) && 
               !modifiers.contains(Modifier.TRANSIENT);
    }

    private void writeImports(Writer writer, List<VariableElement> fields) throws IOException {
        Set<String> imports = fields.stream()
            .map(field -> field.asType().toString())
            .map(this::extractBaseType)  // Extract base type without generics
            .filter(type -> type.contains("."))
            .collect(Collectors.toSet());
        
        for (String importType : imports) {
            writer.write("import " + importType + ";\n");
        }
        writer.write("\n");
    }

    private String extractBaseType(String fullType) {
        // Remove generic type parameters for import statements
        int genericStart = fullType.indexOf('<');
        if (genericStart > 0) {
            return fullType.substring(0, genericStart);
        }
        return fullType;
    }

    private void writeField(Writer writer, VariableElement field) throws IOException {
        // Write field with its type and name
        String type = field.asType().toString();
        String name = field.getSimpleName().toString();
        writer.write("    private " + type + " " + name + ";\n\n");
    }

    private void writeAccessors(Writer writer, VariableElement field) throws IOException {
        String type = field.asType().toString();
        String name = field.getSimpleName().toString();
        String capitalizedName = name.substring(0, 1).toUpperCase() + name.substring(1);
        
        // Getter
        writer.write("    public " + type + " get" + capitalizedName + "() {\n");
        writer.write("        return " + name + ";\n");
        writer.write("    }\n\n");
        
        // Setter
        writer.write("    public void set" + capitalizedName + "(" + type + " " + name + ") {\n");
        writer.write("        this." + name + " = " + name + ";\n");
        writer.write("    }\n\n");
    }
}
