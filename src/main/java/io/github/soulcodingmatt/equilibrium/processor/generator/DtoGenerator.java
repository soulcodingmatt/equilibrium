package io.github.soulcodingmatt.equilibrium.processor.generator;

import io.github.soulcodingmatt.equilibrium.annotations.dto.DtoBuilderDefault;
import io.github.soulcodingmatt.equilibrium.annotations.dto.NestedMapping;
import io.github.soulcodingmatt.equilibrium.annotations.dto.ValidateDto;
import io.github.soulcodingmatt.equilibrium.annotations.dto.validation.*;
import io.github.soulcodingmatt.equilibrium.annotations.dto.validation.Digits;
import io.github.soulcodingmatt.equilibrium.processor.generator.GeneratorUtility.FieldInclusionConfig;
import io.github.soulcodingmatt.equilibrium.processor.generator.GeneratorUtility.GeneratorType;
import io.github.soulcodingmatt.equilibrium.processor.util.CustomObjectDetector;

import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.MirroredTypeException;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.io.Writer;
import java.util.*;
import java.util.stream.Collectors;

public class DtoGenerator {

    // Registry to track generated DTOs: simpleName -> fullQualifiedName
    private static final Map<String, String> generatedDtoRegistry = new HashMap<>();
    public static final String DTO_CLASS = "dtoClass=";
    public static final String MESSAGE = "(message = \"";
    public static final String MESSAGE1 = "message = \"";

    /**
     * Register a generated DTO for import resolution
     * @param simpleName Simple class name (e.g., "BodyDto")
     * @param fullQualifiedName Full qualified name (e.g., "com.soulcodingmatt.dto.BodyDto")
     */
    public static void registerGeneratedDto(String simpleName, String fullQualifiedName) {
        generatedDtoRegistry.put(simpleName, fullQualifiedName);
    }
    
    /**
     * Look up the full qualified name of a generated DTO
     * @param simpleName Simple class name (e.g., "BodyDto")
     * @return Full qualified name if found, null otherwise
     */
    public static String lookupGeneratedDto(String simpleName) {
        return generatedDtoRegistry.get(simpleName);
    }
    
    private final TypeElement classElement;
    private final String packageName;
    private final String dtoClassName;
    private final Set<String> ignoredFields;
    private final boolean builder;
    private final Filer filer;
    private final int dtoId;
    private final Messager messager;

    public DtoGenerator(TypeElement classElement, String packageName, String dtoClassName,
                        Set<String> ignoredFields, boolean builder, int dtoId, Filer filer,
                        Messager messager) {
        this.classElement = classElement;
        this.packageName = packageName;
        this.dtoClassName = dtoClassName;
        this.ignoredFields = ignoredFields != null ? ignoredFields : new HashSet<>();
        this.filer = filer;
        this.builder = builder;
        this.dtoId = dtoId;
        this.messager = messager;
    }

    public void generate() throws IOException {

        // Get all fields that should be included in the DTO
        List<VariableElement> fields = getIncludedFields();
        
        // Create or update the DTO file
        JavaFileObject sourceFile = filer.createSourceFile(packageName + "." + dtoClassName, classElement);
        
        try (Writer writer = sourceFile.openWriter()) {
            // Write package declaration
            writer.write("package " + packageName + ";\n\n");
            
            // Write imports
            if (builder) {
                writer.write("import lombok.experimental.SuperBuilder;\n");
            }
            writer.write("import java.util.Objects;\n");
            writeImports(writer, fields);
            
            // Write class declaration
            writer.write("/**\n");
            writer.write(" * DTO for {@link " + classElement.getQualifiedName() + "}\n");
            writer.write(" * Generated by Project Equilibrium\n");
            writer.write(" */\n");
            if (builder) {
                writer.write("@SuperBuilder\n");
            }
            writer.write("public class " + dtoClassName + " {\n\n");
            
            // Write fields
            for (VariableElement field : fields) {
                writeField(writer, field);
            }
            
            // Write constructor
            writeConstructor(writer, fields, dtoClassName);
            
            // Write getters and setters
            for (VariableElement field : fields) {
                writeAccessors(writer, field);
            }
            
            // Write standard method overrides (always generated)
            writeEquals(writer, fields, dtoClassName);
            writeHashCode(writer, fields);
            writeToString(writer, fields);
            
            // Close class
            writer.write("}\n");
        }
    }

    private List<VariableElement> getIncludedFields() {
        FieldInclusionConfig fieldConfig = new FieldInclusionConfig(GeneratorType.DTO, ignoredFields, dtoId);
        return GeneratorUtility.getIncludedFields(classElement, fieldConfig);
    }

    private void writeImports(Writer writer, List<VariableElement> fields) throws IOException {
        Set<String> imports = new HashSet<>();
        Set<VariableElement> fieldsWithNestedMapping = new HashSet<>();
        
        // First pass: collect fields with @NestedMapping and add their DTO imports
        for (VariableElement field : fields) {
            NestedMapping nestedMapping = field.getAnnotation(NestedMapping.class);
            
            if (nestedMapping != null) {
                fieldsWithNestedMapping.add(field);
                
                String dtoImport = findDtoImportFromSourceClass(nestedMapping);
                if (dtoImport != null) {
                    imports.add(dtoImport);
                }
            }
        }
        
        // Second pass: add standard field imports, BUT skip fields that have @NestedMapping
        Set<String> fieldImports = fields.stream()
            .filter(field -> !fieldsWithNestedMapping.contains(field))  // Skip @NestedMapping fields
            .map(field -> field.asType().toString())  // Get original field types
            .map(GeneratorUtility::extractBaseType)  // Extract base type without generics
            .filter(type -> type.contains("."))
            .collect(Collectors.toSet());
        imports.addAll(fieldImports);
        
        // Add Jakarta Bean Validation imports if validation annotations are used
        Set<String> validationImports = getValidationImports(fields);
        imports.addAll(validationImports);
        
        // Add Builder.Default import if needed and builder is enabled
        if (builder && hasBuilderDefaults(fields)) {
            imports.add("lombok.Builder");
        }
        
        // Add additional imports needed for builder defaults
        Set<String> builderDefaultImports = getBuilderDefaultImports(fields);
        imports.addAll(builderDefaultImports);
        
        // Filter out invalid imports
        Set<String> filteredImports = imports.stream()
            .filter(this::isValidImport)
            .collect(Collectors.toSet());
        
        for (String importType : filteredImports) {
            writer.write("import " + importType + ";\n");
        }
        writer.write("\n");
    }
    
    /**
     * Finds the import statement for a DTO class by examining the source class imports.
     * This avoids TypeMirror resolution issues when the DTO class doesn't exist yet.
     */
    private String findDtoImportFromSourceClass(NestedMapping mapping) {
        // Get the simple DTO class name from the annotation
        String dtoSimpleName = getDtoClassSimpleName(mapping);
        
        // FIRST: Check our generated DTO registry (most reliable!)
        String registeredDto = lookupGeneratedDto(dtoSimpleName);
        if (registeredDto != null) {
            return registeredDto;
        }
        
        // FALLBACK: Use heuristic approach for DTOs not generated by us
        String sourcePackage = classElement.getQualifiedName().toString();
        int lastDot = sourcePackage.lastIndexOf('.');
        if (lastDot > 0) {
            sourcePackage = sourcePackage.substring(0, lastDot);
        }
        
        // Common DTO package patterns - NO hardcoded packages anymore!
        String[] commonDtoPackages = {
            sourcePackage + ".dto",
            sourcePackage.replace(".domain", ".dto"), 
            sourcePackage.replace(".entity", ".dto"),
            sourcePackage.replace(".model", ".dto"),
            sourcePackage
        };
        
        for (String pkgName : commonDtoPackages) {
            String fullName = pkgName + "." + dtoSimpleName;
            if (pkgName.contains("dto")) {
                return fullName;
            }
        }
        
        messager.printMessage(Diagnostic.Kind.WARNING, 
            "Could not determine DTO import for: " + dtoSimpleName);
        return null;
    }
    
    /**
     * Checks if an import type is valid and should be included.
     */
    private boolean isValidImport(String type) {
        // Must contain a dot (package separator)
        if (!type.contains(".")) {
            return false;
        }
        
        // Must not contain invalid characters
        if (type.contains("<") || type.contains(">") || type.contains("?")) {
            return false;
        }
        
        // Must not be a primitive type or java.lang type
        return !type.startsWith("java.lang.") || type.contains("$");
    }
    
    /**
     * Checks if any fields have @DtoBuilderDefault annotations or inherited builder defaults.
     */
    private boolean hasBuilderDefaults(List<VariableElement> fields) {
        for (VariableElement field : fields) {
            // Check for @DtoBuilderDefault annotation
            if (field.getAnnotation(DtoBuilderDefault.class) != null) {
                return true;
            }
            
            // Check for existing @Builder.Default annotation if builder is enabled
            if (builder && hasExistingBuilderDefault(field)) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Gets additional imports needed for builder defaults.
     */
    private Set<String> getBuilderDefaultImports(List<VariableElement> fields) {
        Set<String> imports = new HashSet<>();
        
        if (!builder) {
            return imports; // No builder defaults if builder is disabled
        }
        
        for (VariableElement field : fields) {
            DtoBuilderDefault builderDefault = field.getAnnotation(DtoBuilderDefault.class);
            if (builderDefault != null) {
                // Add imports for collection types that use default constructors
                String fieldType = field.asType().toString();
                if (isCollectionType(fieldType)) {
                    addCollectionImports(imports, fieldType);
                } else if (isOptionalType(fieldType)) {
                    imports.add("java.util.Optional");
                }
                
                // Add enum imports if auto-detected enum types are used
                if (isEnumType(field)) {
                    addEnumImports(imports, field);
                }
            }
        }
        
        return imports;
    }
    
    /**
     * Checks if the field has an existing @Builder.Default annotation.
     */
    private boolean hasExistingBuilderDefault(VariableElement field) {
        // Check if field already has @Builder.Default annotation
        return field.getAnnotationMirrors().stream()
            .anyMatch(mirror -> mirror.getAnnotationType().toString().equals("lombok.Builder.Default"));
    }
    
    /**
     * Checks if the given type is a collection type (List, Set, Map).
     */
    private boolean isCollectionType(String fieldType) {
        String baseType = GeneratorUtility.extractBaseType(fieldType);
        return baseType.equals("java.util.List") || 
               baseType.equals("java.util.Set") || 
               baseType.equals("java.util.Map") ||
               baseType.equals("List") || 
               baseType.equals("Set") || 
               baseType.equals("Map");
    }
    
    /**
     * Checks if the given type is Optional.
     */
    private boolean isOptionalType(String fieldType) {
        String baseType = GeneratorUtility.extractBaseType(fieldType);
        return baseType.equals("java.util.Optional") || baseType.equals("Optional");
    }
    
    /**
     * Adds necessary imports for collection types.
     */
    private void addCollectionImports(Set<String> imports, String fieldType) {
        String baseType = GeneratorUtility.extractBaseType(fieldType);
        switch (baseType) {
            case "java.util.List", "List" -> {
                imports.add("java.util.List");
                imports.add("java.util.ArrayList");
            }
            case "java.util.Set", "Set" -> {
                imports.add("java.util.Set");
                imports.add("java.util.HashSet");
            }
            case "java.util.Map", "Map" -> {
                imports.add("java.util.Map");
                imports.add("java.util.HashMap");
            }
        }
    }


    
    private Set<String> getValidationImports(List<VariableElement> fields) {
        Set<String> validationImports = new HashSet<>();
        
        for (VariableElement field : fields) {
            ValidateDto[] validateAnnotations = field.getAnnotationsByType(ValidateDto.class);
            
            for (ValidateDto validateAnnotation : validateAnnotations) {
                if (shouldApplyValidation(validateAnnotation)) {
                    // Add imports for type-safe validations
                    addTypeSafeValidationImports(validationImports, validateAnnotation);
                    
                    // Add imports for legacy string-based validations
                    for (String validation : validateAnnotation.value()) {
                        if (!validation.trim().isEmpty()) {
                            String annotationClass = extractAnnotationClass(validation);
                            if (annotationClass != null) {
                                validationImports.add(annotationClass);
                            }
                        }
                    }
                }
            }
        }
        
        return validationImports;
    }
    
    private void addTypeSafeValidationImports(Set<String> validationImports, ValidateDto validateAnnotation) {
        // Check which type-safe validations are explicitly configured and add their imports
        
        // Simple annotations: Check if explicitly specified (message != empty string default)
        if (!validateAnnotation.notNull().message().equals("")) {
            validationImports.add("jakarta.validation.constraints.NotNull");
        }
        
        if (!validateAnnotation.notBlank().message().equals("")) {
            validationImports.add("jakarta.validation.constraints.NotBlank");
        }
        
        if (!validateAnnotation.notEmpty().message().equals("")) {
            validationImports.add("jakarta.validation.constraints.NotEmpty");
        }
        
        if (!validateAnnotation.positive().message().equals("")) {
            validationImports.add("jakarta.validation.constraints.Positive");
        }
        
        if (!validateAnnotation.positiveOrZero().message().equals("")) {
            validationImports.add("jakarta.validation.constraints.PositiveOrZero");
        }
        
        if (!validateAnnotation.negative().message().equals("")) {
            validationImports.add("jakarta.validation.constraints.Negative");
        }
        
        if (!validateAnnotation.negativeOrZero().message().equals("")) {
            validationImports.add("jakarta.validation.constraints.NegativeOrZero");
        }
        
        if (!validateAnnotation.past().message().equals("")) {
            validationImports.add("jakarta.validation.constraints.Past");
        }
        
        if (!validateAnnotation.future().message().equals("")) {
            validationImports.add("jakarta.validation.constraints.Future");
        }
        
        if (!validateAnnotation.pastOrPresent().message().equals("")) {
            validationImports.add("jakarta.validation.constraints.PastOrPresent");
        }
        
        if (!validateAnnotation.futureOrPresent().message().equals("")) {
            validationImports.add("jakarta.validation.constraints.FutureOrPresent");
        }
        
        if (!validateAnnotation.email().message().equals("")) {
            validationImports.add("jakarta.validation.constraints.Email");
        }
        
        // Parameterized annotations: Check if meaningful parameters are provided
        Size size = validateAnnotation.size();
        if (size.min() != -1 || size.max() != -1) {
            validationImports.add("jakarta.validation.constraints.Size");
        }
        
        if (validateAnnotation.min().value() != Long.MIN_VALUE) {
            validationImports.add("jakarta.validation.constraints.Min");
        }
        
        if (validateAnnotation.max().value() != Long.MAX_VALUE) {
            validationImports.add("jakarta.validation.constraints.Max");
        }
        
        if (!validateAnnotation.pattern().regexp().isEmpty()) {
            validationImports.add("jakarta.validation.constraints.Pattern");
        }
        
        Digits digits = validateAnnotation.digits();
        if (digits.integer() != -1 || digits.fraction() != -1) {
            validationImports.add("jakarta.validation.constraints.Digits");
        }
    }
    
    private String extractAnnotationClass(String annotationString) {
        // Extract annotation class name from annotation string like "@NotNull" or "@Size(min=1, max=100)"
        String trimmed = annotationString.trim();
        if (!trimmed.startsWith("@")) {
            return null;
        }
        
        // Remove @ and get the annotation name
        String withoutAt = trimmed.substring(1);
        int parenIndex = withoutAt.indexOf('(');
        String annotationName = parenIndex > 0 ? withoutAt.substring(0, parenIndex) : withoutAt;
        
        // Map common validation annotations to their full package names
        return getValidationAnnotationImport(annotationName);
    }
    
    private String getValidationAnnotationImport(String annotationName) {
        // Map common Jakarta Bean Validation annotations to their import paths
        return switch (annotationName) {
            case "NotNull" -> "jakarta.validation.constraints.NotNull";
            case "NotEmpty" -> "jakarta.validation.constraints.NotEmpty";
            case "NotBlank" -> "jakarta.validation.constraints.NotBlank";
            case "Size" -> "jakarta.validation.constraints.Size";
            case "Min" -> "jakarta.validation.constraints.Min";
            case "Max" -> "jakarta.validation.constraints.Max";
            case "DecimalMin" -> "jakarta.validation.constraints.DecimalMin";
            case "DecimalMax" -> "jakarta.validation.constraints.DecimalMax";
            case "Positive" -> "jakarta.validation.constraints.Positive";
            case "PositiveOrZero" -> "jakarta.validation.constraints.PositiveOrZero";
            case "Negative" -> "jakarta.validation.constraints.Negative";
            case "NegativeOrZero" -> "jakarta.validation.constraints.NegativeOrZero";
            case "Email" -> "jakarta.validation.constraints.Email";
            case "Pattern" -> "jakarta.validation.constraints.Pattern";
            case "Digits" -> "jakarta.validation.constraints.Digits";
            case "Future" -> "jakarta.validation.constraints.Future";
            case "FutureOrPresent" -> "jakarta.validation.constraints.FutureOrPresent";
            case "Past" -> "jakarta.validation.constraints.Past";
            case "PastOrPresent" -> "jakarta.validation.constraints.PastOrPresent";
            case "AssertTrue" -> "jakarta.validation.constraints.AssertTrue";
            case "AssertFalse" -> "jakarta.validation.constraints.AssertFalse";
            case "Valid" -> "jakarta.validation.Valid";
            default -> null; // Unknown annotation, skip import
        };
    }

    private boolean shouldApplyValidation(ValidateDto validateAnnotation) {
        int[] validationIds = validateAnnotation.ids();
        
        // If no IDs specified, apply validation to all DTOs
        if (validationIds.length == 0) {
            return true;
        }
        
        // If IDs specified, only apply if current DTO ID is in the list
        for (int validationId : validationIds) {
            if (validationId == dtoId) {
                return true;
            }
        }
        
        return false;
    }
    
    private void writeTypeSafeValidations(Writer writer, ValidateDto validateAnnotation) throws IOException {
        // Check NotNull validation
        NotNull notNull = validateAnnotation.notNull();
        if (!notNull.message().equals("")) {
            writer.write("    @NotNull");
            if (!notNull.message().equals("must not be null")) {
                writer.write(MESSAGE + escapeQuotes(notNull.message()) + "\")");
            }
            writer.write("\n");
        }
        
        // Check NotBlank validation
        NotBlank notBlank = validateAnnotation.notBlank();
        if (!notBlank.message().equals("")) {
            writer.write("    @NotBlank");
            if (!notBlank.message().equals("must not be blank")) {
                writer.write(MESSAGE + escapeQuotes(notBlank.message()) + "\")");
            }
            writer.write("\n");
        }
        
        // Check Size validation
        Size size = validateAnnotation.size();
        if (size.min() != -1 || size.max() != -1) {
            writer.write("    @Size");
            List<String> params = new ArrayList<>();
            if (size.min() != -1 && size.min() != 0) {
                params.add("min = " + size.min());
            }
            if (size.max() != -1 && size.max() != Integer.MAX_VALUE) {
                params.add("max = " + size.max());
            }
            if (!size.message().equals("") && !size.message().equals("size must be between {min} and {max}")) {
                params.add(MESSAGE1 + escapeQuotes(size.message()) + "\"");
            }
            if (!params.isEmpty()) {
                writer.write("(" + String.join(", ", params) + ")");
            }
            writer.write("\n");
        }
        
        // Check Min validation
        Min min = validateAnnotation.min();
        if (min.value() != Long.MIN_VALUE) {
            writer.write("    @Min");
            List<String> params = new ArrayList<>();
            params.add("value = " + min.value());
            if (!min.message().equals("") && !min.message().equals("must be greater than or equal to {value}")) {
                params.add(MESSAGE1 + escapeQuotes(min.message()) + "\"");
            }
            writer.write("(" + String.join(", ", params) + ")");
            writer.write("\n");
        }
        
        // Check Max validation
        Max max = validateAnnotation.max();
        if (max.value() != Long.MAX_VALUE) {
            writer.write("    @Max");
            List<String> params = new ArrayList<>();
            params.add("value = " + max.value());
            if (!max.message().equals("") && !max.message().equals("must be less than or equal to {value}")) {
                params.add(MESSAGE1 + escapeQuotes(max.message()) + "\"");
            }
            writer.write("(" + String.join(", ", params) + ")");
            writer.write("\n");
        }
        
        // Check Email validation
        Email email = validateAnnotation.email();
        if (!email.message().equals("")) {
            writer.write("    @Email");
            List<String> params = new ArrayList<>();
            if (!email.regexp().equals(".*")) {
                params.add("regexp = \"" + escapeQuotes(email.regexp()) + "\"");
            }
            if (!email.message().equals("") && !email.message().equals("must be a well-formed email address")) {
                params.add(MESSAGE1 + escapeQuotes(email.message()) + "\"");
            }
            if (!params.isEmpty()) {
                writer.write("(" + String.join(", ", params) + ")");
            }
            writer.write("\n");
        }
        
        // Check Pattern validation
        Pattern pattern = validateAnnotation.pattern();
        if (!pattern.regexp().isEmpty()) {
            writer.write("    @Pattern");
            List<String> params = new ArrayList<>();
            params.add("regexp = \"" + escapeQuotes(pattern.regexp()) + "\"");
            if (!pattern.message().equals("") && !pattern.message().equals("must match \"{regexp}\"")) {
                params.add(MESSAGE1 + escapeQuotes(pattern.message()) + "\"");
            }
            writer.write("(" + String.join(", ", params) + ")");
            writer.write("\n");
        }
        
        // Check NotEmpty validation
        NotEmpty notEmpty = validateAnnotation.notEmpty();
        if (!notEmpty.message().equals("")) {
            writer.write("    @NotEmpty");
            if (!notEmpty.message().equals("must not be empty")) {
                writer.write(MESSAGE + escapeQuotes(notEmpty.message()) + "\")");
            }
            writer.write("\n");
        }
        
        // Check Positive validation
        Positive positive = validateAnnotation.positive();
        if (!positive.message().equals("")) {
            writer.write("    @Positive");
            if (!positive.message().equals("must be greater than 0")) {
                writer.write(MESSAGE + escapeQuotes(positive.message()) + "\")");
            }
            writer.write("\n");
        }
        
        // Check PositiveOrZero validation
        PositiveOrZero positiveOrZero = validateAnnotation.positiveOrZero();
        if (!positiveOrZero.message().equals("")) {
            writer.write("    @PositiveOrZero");
            if (!positiveOrZero.message().equals("must be greater than or equal to 0")) {
                writer.write(MESSAGE + escapeQuotes(positiveOrZero.message()) + "\")");
            }
            writer.write("\n");
        }
        
        // Check Negative validation
        Negative negative = validateAnnotation.negative();
        if (!negative.message().equals("")) {
            writer.write("    @Negative");
            if (!negative.message().equals("must be less than 0")) {
                writer.write(MESSAGE + escapeQuotes(negative.message()) + "\")");
            }
            writer.write("\n");
        }
        
        // Check NegativeOrZero validation
        NegativeOrZero negativeOrZero = validateAnnotation.negativeOrZero();
        if (!negativeOrZero.message().equals("")) {
            writer.write("    @NegativeOrZero");
            if (!negativeOrZero.message().equals("must be less than or equal to 0")) {
                writer.write(MESSAGE + escapeQuotes(negativeOrZero.message()) + "\")");
            }
            writer.write("\n");
        }
        
        // Check Digits validation
        Digits digits = validateAnnotation.digits();
        if (digits.integer() != -1 || digits.fraction() != -1) {
            writer.write("    @Digits");
            List<String> params = new ArrayList<>();
            if (digits.integer() != -1) {
                params.add("integer = " + digits.integer());
            }
            if (digits.fraction() != -1) {
                params.add("fraction = " + digits.fraction());
            }
            if (!digits.message().equals("") && !digits.message().equals("numeric value out of bounds (<{integer} digits>.<{fraction} digits> expected)")) {
                params.add(MESSAGE1 + escapeQuotes(digits.message()) + "\"");
            }
            if (!params.isEmpty()) {
                writer.write("(" + String.join(", ", params) + ")");
            }
            writer.write("\n");
        }
        
        // Check Past validation
        Past past = validateAnnotation.past();
        if (!past.message().equals("")) {
            writer.write("    @Past");
            if (!past.message().equals("must be a date in the past")) {
                writer.write(MESSAGE + escapeQuotes(past.message()) + "\")");
            }
            writer.write("\n");
        }
        
        // Check Future validation
        Future future = validateAnnotation.future();
        if (!future.message().equals("")) {
            writer.write("    @Future");
            if (!future.message().equals("must be a date in the future")) {
                writer.write(MESSAGE + escapeQuotes(future.message()) + "\")");
            }
            writer.write("\n");
        }
        
        // Check PastOrPresent validation
        PastOrPresent pastOrPresent = validateAnnotation.pastOrPresent();
        if (!pastOrPresent.message().equals("")) {
            writer.write("    @PastOrPresent");
            if (!pastOrPresent.message().equals("must be a date in the past or in the present")) {
                writer.write(MESSAGE + escapeQuotes(pastOrPresent.message()) + "\")");
            }
            writer.write("\n");
        }
        
        // Check FutureOrPresent validation
        FutureOrPresent futureOrPresent = validateAnnotation.futureOrPresent();
        if (!futureOrPresent.message().equals("")) {
            writer.write("    @FutureOrPresent");
            if (!futureOrPresent.message().equals("must be a date in the present or in the future")) {
                writer.write(MESSAGE + escapeQuotes(futureOrPresent.message()) + "\")");
            }
            writer.write("\n");
        }
    }
    

    
    private String escapeQuotes(String text) {
        return text.replace("\\", "\\\\").replace("\"", "\\\"");
    }
    
    /**
     * Transforms the field type based on @NestedMapping annotations.
     * Returns simple names for use in field declarations, getters, setters, constructor.
     */
    private String getTransformedFieldType(VariableElement field) {
        TypeMirror fieldType = field.asType();
        String originalType = fieldType.toString();
        
        // Get @NestedMapping annotation for this field
        NestedMapping nestedMapping = field.getAnnotation(NestedMapping.class);
        
        if (nestedMapping != null) {
            // Transform the type using the specified DTO class (simple name for declarations)
            return transformTypeWithMappingSimpleName(fieldType, nestedMapping);
        }
        
        // Return original type if no transformation is needed
        return originalType;
    }


    /**
     * Transforms a field type using the specified DTO mapping.
     * Returns simple names for field declarations.
     */
    private String transformTypeWithMappingSimpleName(TypeMirror fieldType, NestedMapping mapping) {
        String dtoClassSimpleName = getDtoClassSimpleName(mapping);
        
        // Check if this is a collection type
        TypeMirror elementType = CustomObjectDetector.getCollectionElementType(fieldType);
        if (elementType != null) {
            // Transform collection element type: List<CustomObject> -> List<CustomObjectDto>
            String originalType = fieldType.toString();
            String originalElementType = elementType.toString();
            
            // Replace the element simple name with the DTO simple name
            return originalType.replace(originalElementType, dtoClassSimpleName);
        } else {
            // Direct type transformation: CustomObject -> CustomObjectDto (using simple name)
            return dtoClassSimpleName;
        }
    }
    
    /**
     * Safely extracts the simple name of the DTO class from @NestedMapping annotation.
     * Uses string parsing to avoid TypeMirror resolution issues.
     */
    private String getDtoClassSimpleName(NestedMapping mapping) {
        try {
            // This will throw MirroredTypeException during annotation processing
            return mapping.dtoClass().getSimpleName();
        } catch (MirroredTypeException mte) {
            // Extract the TypeMirror from the exception
            TypeMirror typeMirror = mte.getTypeMirror();
            String typeMirrorString = typeMirror.toString();
            
            // If TypeMirror resolution failed (ERROR kind), try to extract from string representation
            if (typeMirror.getKind() == TypeKind.ERROR || typeMirrorString.contains("<any?>")) {
                
                // Try to extract the simple name from strings like "<any?>.FunkyShitDto" or "FunkyShitDto"
                if (typeMirrorString.contains(".")) {
                    String simpleName = typeMirrorString.substring(typeMirrorString.lastIndexOf('.') + 1);
                    // Only proceed if we got a valid class name (not "<any>")
                    if (!simpleName.contains("<") && !simpleName.contains(">") && !simpleName.isEmpty()) {
                        return simpleName;
                    }
                }
                
                // If TypeMirror resolution completely failed (e.g., <any?>.<any>), 
                // try to extract class name from the annotation source using reflection
                    
                try {
                    // Use reflection to get the annotation's toString representation
                    String annotationString = mapping.toString();
                    
                    // Extract class name from patterns like "dtoClass=FunkyShitDto.class"
                    if (annotationString.contains(DTO_CLASS) && annotationString.contains(".class")) {
                        int start = annotationString.indexOf(DTO_CLASS) + DTO_CLASS.length();
                        int end = annotationString.indexOf(".class", start);
                        if (start > 0 && end > start) {
                            String classReference = annotationString.substring(start, end);
                            // Remove any package prefixes to get simple name
                            if (classReference.contains(".")) {
                                classReference = classReference.substring(classReference.lastIndexOf('.') + 1);
                            }
                            return classReference;
                        }
                    }
                } catch (Exception e) {
                    // Annotation source parsing failed, continue to error
                }
                
                // If we couldn't extract a valid name, this is a real error
                messager.printMessage(Diagnostic.Kind.ERROR, 
                    "Cannot resolve DTO class in @NestedMapping annotation. " +
                    "TypeMirror resolution failed: " + typeMirrorString + ". " +
                    "Please ensure the referenced DTO class exists and is on the classpath.");
                throw new IllegalStateException("Cannot resolve DTO class in @NestedMapping: " + typeMirrorString);
            }
            
            // Get the simple name from the TypeMirror (normal case)
            if (typeMirror.getKind() == TypeKind.DECLARED) {
                DeclaredType declaredType = (DeclaredType) typeMirror;
                TypeElement typeElement = (TypeElement) declaredType.asElement();
                return typeElement.getSimpleName().toString();
            }
            
            // Fallback: extract simple name from string representation
            String fullName = typeMirror.toString();
            int lastDotIndex = fullName.lastIndexOf('.');
            return lastDotIndex > 0 ? fullName.substring(lastDotIndex + 1) : fullName;
        }
    }
    
    /**
     * Checks if a field contains unmapped custom objects and generates warnings.
     */
    private void checkForUnmappedCustomObjects(VariableElement field, TypeMirror fieldType) {
        String fieldName = field.getSimpleName().toString();
        
        // Check direct custom object
        if (CustomObjectDetector.isCustomObject(fieldType)) {
            String customTypeName = fieldType.toString();
            String suggestedDtoName = getSuggestedDtoName(customTypeName);
            
            String message = String.format(
                "[%s] Field '%s' uses custom type '%s' without DTO mapping.%n" +
                "  Consider: @NestedMapping(dtoClass = %s.class)%n" +
                "  Location: %s.%s",
                dtoClassName, fieldName, customTypeName, suggestedDtoName,
                classElement.getQualifiedName(), fieldName
            );
            
            messager.printMessage(Diagnostic.Kind.WARNING, message, field);
        }
        
        // Check collection of custom objects
        if (CustomObjectDetector.isCustomObjectCollection(fieldType)) {
            TypeMirror elementType = CustomObjectDetector.getCollectionElementType(fieldType);
            if (elementType != null) {
                String customTypeName = elementType.toString();
                String suggestedDtoName = getSuggestedDtoName(customTypeName);
                
                String message = String.format(
                    "[%s] Field '%s' uses collection of custom type '%s' without DTO mapping.%n" +
                    "  Consider: @NestedMapping(dtoClass = %s.class)%n" +
                    "  Location: %s.%s",
                    dtoClassName, fieldName, customTypeName, suggestedDtoName,
                    classElement.getQualifiedName(), fieldName
                );
                
                messager.printMessage(Diagnostic.Kind.WARNING, message, field);
            }
        }
    }
    
    /**
     * Suggests a DTO name based on the custom type name.
     */
    private String getSuggestedDtoName(String customTypeName) {
        // Extract simple class name from fully qualified name
        String simpleClassName = customTypeName;
        int lastDotIndex = customTypeName.lastIndexOf('.');
        if (lastDotIndex > 0) {
            simpleClassName = customTypeName.substring(lastDotIndex + 1);
        }
        
        // Suggest DTO name by appending "Dto"
        return simpleClassName + "Dto";
    }
    
    /**
     * Writes @Builder.Default annotation if applicable.
     */
    private void writeBuilderDefaultAnnotation(Writer writer, VariableElement field) throws IOException {
        if (!builder) {
            return; // No builder defaults if builder is disabled
        }
        
        // Check for @DtoBuilderDefault annotation
        DtoBuilderDefault builderDefault = field.getAnnotation(DtoBuilderDefault.class);
        if (builderDefault != null) {
            // Validate that field is not final
            if (field.getModifiers().contains(javax.lang.model.element.Modifier.FINAL)) {
                messager.printMessage(Diagnostic.Kind.ERROR, 
                    "@DtoBuilderDefault cannot be applied to final fields: " + field.getSimpleName(), 
                    field);
                return;
            }
            
            writer.write("    @Builder.Default\n");
            return;
        }
        
        // Check for existing @Builder.Default annotation from base class
        if (hasExistingBuilderDefault(field)) {
            writer.write("    @Builder.Default\n");
        }
    }
    
    /**
     * Gets the field declaration including type, name, and optional default value.
     */
    private String getFieldDeclaration(VariableElement field, String transformedType, String name) {
        if (!builder) {
            return transformedType + " " + name; // No defaults if builder is disabled
        }
        
        // Check for @DtoBuilderDefault annotation
        DtoBuilderDefault builderDefault = field.getAnnotation(DtoBuilderDefault.class);
        if (builderDefault != null) {
            String defaultValue = getBuilderDefaultValue(field, builderDefault);
            if (defaultValue != null && !defaultValue.isEmpty()) {
                return transformedType + " " + name + " = " + defaultValue;
            }
        }
        
        // Check for existing builder default from base class
        if (hasExistingBuilderDefault(field)) {
            String existingDefault = getExistingBuilderDefaultValue(field);
            if (existingDefault != null && !existingDefault.isEmpty()) {
                return transformedType + " " + name + " = " + existingDefault;
            }
        }
        
        return transformedType + " " + name;
    }
    
    /**
     * Gets the default value for a field with @DtoBuilderDefault annotation.
     */
    private String getBuilderDefaultValue(VariableElement field, DtoBuilderDefault builderDefault) {
        String fieldType = field.asType().toString();
        String annotationValue = builderDefault.value();
        
        // If explicit value is provided, process it based on field type
        if (!annotationValue.isEmpty()) {
            return processAnnotationValue(field, fieldType, annotationValue);
        }
        
        // Special handling for collections and Optional
        if (isCollectionType(fieldType)) {
            return getCollectionDefaultValue(fieldType);
        } else if (isOptionalType(fieldType)) {
            return "Optional.empty()";
        }
        
        // For other types, require explicit value
        messager.printMessage(Diagnostic.Kind.ERROR, 
            "@DtoBuilderDefault requires a value for non-collection, non-Optional field: " + field.getSimpleName(), 
            field);
        return null;
    }
    
    /**
     * Processes the annotation value based on the field type.
     * Handles String auto-quoting and enum auto-detection with validation.
     */
    private String processAnnotationValue(VariableElement field, String fieldType, String annotationValue) {
        // Check if this is an enum field (auto-detect from field type)
        if (isEnumType(field)) {
            return processEnumValue(field, annotationValue);
        }
        
        // Check if this is a String field
        if (isStringType(fieldType)) {
            // If the value already has quotes (escaped or not), use it as-is
            if (annotationValue.startsWith("\"") && annotationValue.endsWith("\"")) {
                return annotationValue; // Already properly quoted
            }
            if (annotationValue.startsWith("\\\"") && annotationValue.endsWith("\\\"")) {
                return annotationValue; // Already escaped and quoted
            }
            
            // Auto-add quotes for String fields
            return "\"" + escapeQuotes(annotationValue) + "\"";
        }
        
        // For other types, use the value as-is
        return annotationValue;
    }
    
    /**
     * Checks if a field is of enum type.
     */
    private boolean isEnumType(VariableElement field) {
        return field.asType().getKind() == javax.lang.model.type.TypeKind.DECLARED &&
               ((javax.lang.model.type.DeclaredType) field.asType()).asElement().getKind() == javax.lang.model.element.ElementKind.ENUM;
    }
    
    /**
     * Processes enum values with auto-detection and validation.
     */
    private String processEnumValue(VariableElement field, String annotationValue) {
        String fieldName = field.getSimpleName().toString();
        javax.lang.model.type.DeclaredType declaredType = (javax.lang.model.type.DeclaredType) field.asType();
        javax.lang.model.element.TypeElement enumElement = (javax.lang.model.element.TypeElement) declaredType.asElement();
        String enumClassName = enumElement.getQualifiedName().toString();
        String enumSimpleName = enumElement.getSimpleName().toString();
        
        // Support both simple constant names ("ACTIVE") and qualified names ("Status.ACTIVE")
        String constantName;
        String specifiedEnumName = null;
        
        if (annotationValue.contains(".")) {
            // Qualified reference like "Status.ACTIVE"
            String[] parts = annotationValue.split("\\.");
            if (parts.length != 2) {
                messager.printMessage(Diagnostic.Kind.ERROR, 
                    "@DtoBuilderDefault: Invalid enum reference format '" + annotationValue + 
                    "'. Expected 'EnumName.CONSTANT' or 'CONSTANT' for field: " + fieldName, field);
                return null;
            }
            specifiedEnumName = parts[0];
            constantName = parts[1];
            
            // Validate that the specified enum name matches the field type
            if (!specifiedEnumName.equals(enumSimpleName) && !specifiedEnumName.equals(enumClassName)) {
                messager.printMessage(Diagnostic.Kind.ERROR, 
                    "@DtoBuilderDefault: Enum reference '" + specifiedEnumName + 
                    "' does not match field type '" + enumClassName + "' for field: " + fieldName, field);
                return null;
            }
        } else {
            // Simple constant name like "ACTIVE"
            constantName = annotationValue;
        }
        
        // Validate that the constant exists in the enum
        boolean constantExists = false;
        for (javax.lang.model.element.Element enclosedElement : enumElement.getEnclosedElements()) {
            if (enclosedElement.getKind() == javax.lang.model.element.ElementKind.ENUM_CONSTANT &&
                enclosedElement.getSimpleName().toString().equals(constantName)) {
                constantExists = true;
                break;
            }
        }
        
        if (!constantExists) {
            messager.printMessage(Diagnostic.Kind.ERROR, 
                "@DtoBuilderDefault: Enum constant '" + constantName + 
                "' does not exist in enum " + enumClassName + " for field: " + fieldName, field);
            return null;
        }
        
        // Generate the proper enum reference
        return enumSimpleName + "." + constantName;
    }
    
    /**
     * Adds necessary imports for enum types used in builder defaults.
     */
    private void addEnumImports(Set<String> imports, VariableElement field) {
        if (isEnumType(field)) {
            javax.lang.model.type.DeclaredType declaredType = (javax.lang.model.type.DeclaredType) field.asType();
            javax.lang.model.element.TypeElement enumElement = (javax.lang.model.element.TypeElement) declaredType.asElement();
            String enumClassName = enumElement.getQualifiedName().toString();
            
            // Add import if it's not in java.lang package
            if (enumClassName.contains(".") && !enumClassName.startsWith("java.lang.")) {
                imports.add(enumClassName);
            }
        }
    }
    
    /**
     * Checks if the given type is a String type.
     */
    private boolean isStringType(String fieldType) {
        String baseType = GeneratorUtility.extractBaseType(fieldType);
        return baseType.equals("java.lang.String") || baseType.equals("String");
    }
    
    /**
     * Gets the appropriate default value for collection types.
     */
    private String getCollectionDefaultValue(String fieldType) {
        String baseType = GeneratorUtility.extractBaseType(fieldType);
        return switch (baseType) {
            case "java.util.List", "List" -> "new ArrayList<>()";
            case "java.util.Set", "Set" -> "new HashSet<>()";
            case "java.util.Map", "Map" -> "new HashMap<>()";
            default -> null;
        };
    }
    
    /**
     * Gets the existing default value from a field that already has @Builder.Default.
     * This is a simplified implementation - in practice, you might need more sophisticated parsing.
     */
    private String getExistingBuilderDefaultValue(VariableElement field) {
        // This is a placeholder - extracting existing default values from source code
        // would require parsing the field initializer, which is complex in annotation processing.
        // For now, return null to indicate no default value extraction.
        return null;
    }

    private void writeField(Writer writer, VariableElement field) throws IOException {
        // Check for validation annotations (handles both single and multiple ValidateDto annotations)
        ValidateDto[] validateAnnotations = field.getAnnotationsByType(ValidateDto.class);
        
        for (ValidateDto validateAnnotation : validateAnnotations) {
            if (shouldApplyValidation(validateAnnotation)) {
                // Write type-safe validation annotations
                writeTypeSafeValidations(writer, validateAnnotation);
                
                // Write legacy string-based validation annotations (for backward compatibility)
                for (String validation : validateAnnotation.value()) {
                    if (!validation.trim().isEmpty()) {
                        writer.write("    " + validation + "\n");
                    }
                }
            }
        }
        
        // Write builder default annotations if builder is enabled
        writeBuilderDefaultAnnotation(writer, field);
        
        // Transform field type based on @NestedMapping annotations
        String transformedType = getTransformedFieldType(field);
        String name = field.getSimpleName().toString();
        
        // Check for unmapped custom objects and warn (only during field declaration)
        TypeMirror fieldType = field.asType();
        NestedMapping nestedMapping = field.getAnnotation(NestedMapping.class);
        if (nestedMapping == null) {
            checkForUnmappedCustomObjects(field, fieldType);
        }
        
        // Write field declaration with optional default value
        String fieldDeclaration = getFieldDeclaration(field, transformedType, name);
        writer.write("    private " + fieldDeclaration + ";\n\n");
    }

    private void writeAccessors(Writer writer, VariableElement field) throws IOException {
        // Transform field type based on @NestedMapping annotations
        String type = getTransformedFieldType(field);
        String name = field.getSimpleName().toString();
        String capitalizedName = name.substring(0, 1).toUpperCase() + name.substring(1);
        
        // Getter
        writer.write("    public " + type + " get" + capitalizedName + "() {\n");
        writer.write("        return " + name + ";\n");
        writer.write(GeneratorUtility.STRING_END);
        
        // Setter
        writer.write("    public void set" + capitalizedName + "(" + type + " " + name + ") {\n");
        writer.write("        this." + name + " = " + name + ";\n");
        writer.write(GeneratorUtility.STRING_END);
    }

    private void writeConstructor(Writer writer, List<VariableElement> fields, String className) throws IOException {
        writer.write("    public " + className + "(");
        
        // Write constructor parameters
        boolean first = true;
        for (VariableElement field : fields) {
            if (!first) {
                writer.write(", ");
            }
            // Transform field type based on @NestedMapping annotations
            String type = getTransformedFieldType(field);
            String name = field.getSimpleName().toString();
            writer.write(type + " " + name);
            first = false;
        }
        writer.write(") {\n");
        
        // Write field assignments
        for (VariableElement field : fields) {
            String name = field.getSimpleName().toString();
            writer.write("        this." + name + " = " + name + ";\n");
        }
        writer.write(GeneratorUtility.STRING_END);
    }

    private void writeEquals(Writer writer, List<VariableElement> fields, String className) throws IOException {
        GeneratorUtility.writeEquals(writer, fields, className);
    }

    private void writeHashCode(Writer writer, List<VariableElement> fields) throws IOException {
        GeneratorUtility.writeHashCode(writer, fields);
    }

    private void writeToString(Writer writer, List<VariableElement> fields) throws IOException {
        GeneratorUtility.writeToString(writer, fields, dtoClassName);
    }
}
