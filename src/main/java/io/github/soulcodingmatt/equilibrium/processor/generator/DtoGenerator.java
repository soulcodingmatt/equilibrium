package io.github.soulcodingmatt.equilibrium.processor.generator;

import io.github.soulcodingmatt.equilibrium.annotations.common.IgnoreAll;
import io.github.soulcodingmatt.equilibrium.annotations.dto.IgnoreDto;

import javax.annotation.processing.Filer;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.type.TypeKind;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.io.Writer;
import java.util.List;
import java.util.Set;
import java.util.HashSet;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class DtoGenerator {
    public static final String STRING_END = "    }\n\n";
    public static final String OVERRIDE = "    @Override\n";
    private final TypeElement classElement;
    private final String packageName;
    private final String dtoClassName;
    private final Set<String> ignoredFields;
    private final boolean builder;
    private final Filer filer;
    private final int dtoId;

    public DtoGenerator(TypeElement classElement, String packageName, String dtoClassName,
                        Set<String> ignoredFields, boolean builder, int dtoId, Filer filer) {
        this.classElement = classElement;
        this.packageName = packageName;
        this.dtoClassName = dtoClassName;
        this.ignoredFields = ignoredFields != null ? ignoredFields : new HashSet<>();
        this.filer = filer;
        this.builder = builder;
        this.dtoId = dtoId;
    }

    public void generate() throws IOException {
        String className = classElement.getSimpleName().toString();
        
        // Get all fields that should be included in the DTO
        List<VariableElement> fields = getIncludedFields();
        
        // Create or update the DTO file
        JavaFileObject sourceFile = filer.createSourceFile(packageName + "." + dtoClassName, classElement);
        
        try (Writer writer = sourceFile.openWriter()) {
            // Write package declaration
            writer.write("package " + packageName + ";\n\n");
            
            // Write imports
            if (builder) {
                writer.write("import lombok.experimental.SuperBuilder;\n");
            }
            writer.write("import java.util.Objects;\n");
            writeImports(writer, fields);
            
            // Write class declaration
            writer.write("/**\n");
            writer.write(" * DTO for {@link " + classElement.getQualifiedName() + "}\n");
            writer.write(" * Generated by Project Equilibrium\n");
            writer.write(" */\n");
            if (builder) {
                writer.write("@SuperBuilder\n");
            }
            writer.write("public class " + dtoClassName + " {\n\n");
            
            // Write fields
            for (VariableElement field : fields) {
                writeField(writer, field);
            }
            
            // Write getters and setters
            for (VariableElement field : fields) {
                writeAccessors(writer, field);
            }
            
            // Write standard method overrides (always generated)
            writeEquals(writer, fields, dtoClassName);
            writeHashCode(writer, fields);
            writeToString(writer, fields);
            
            // Close class
            writer.write("}\n");
        }
    }

    private List<VariableElement> getIncludedFields() {
        return collectFieldsFromHierarchy(classElement);
    }

    private List<VariableElement> collectFieldsFromHierarchy(TypeElement element) {
        List<VariableElement> fields = element.getEnclosedElements().stream()
            .filter(e -> e.getKind() == ElementKind.FIELD)
            .map(VariableElement.class::cast)
            .filter(this::shouldIncludeField)
            .toList();

        // Get parent class fields
        TypeMirror superclass = element.getSuperclass();
        if (superclass.getKind() != TypeKind.NONE && !superclass.toString().equals("java.lang.Object")) {
            TypeElement superclassElement = (TypeElement) ((DeclaredType) superclass).asElement();
            fields = Stream.concat(
                fields.stream(),
                collectFieldsFromHierarchy(superclassElement).stream()
            ).toList();
        }

        return fields;
    }

    private boolean shouldIncludeField(VariableElement field) {
        // Exclude fields marked with @IgnoreAll
        if (field.getAnnotation(IgnoreAll.class) != null) {
            return false;
        }
        
        // Handle ID-based @IgnoreDto exclusion
        IgnoreDto ignoreDtoAnnotation = field.getAnnotation(IgnoreDto.class);
        if (ignoreDtoAnnotation != null) {
            int[] ignoredIds = ignoreDtoAnnotation.ids();
            
            // If no IDs specified, ignore for all DTOs
            if (ignoredIds.length == 0) {
                return false;
            }
            
            // If IDs specified, only ignore if current DTO ID is in the list
            for (int ignoredId : ignoredIds) {
                if (ignoredId == dtoId) {
                    return false;
                }
            }
        }
        
        // Exclude any fields specified in the ignore collection
        String fieldName = field.getSimpleName().toString();
        if (ignoredFields.contains(fieldName)) {
            return false;
        }
        
        // Exclude static and transient fields
        Set<Modifier> modifiers = field.getModifiers();
        return !modifiers.contains(Modifier.STATIC) && 
               !modifiers.contains(Modifier.TRANSIENT);
    }

    private void writeImports(Writer writer, List<VariableElement> fields) throws IOException {
        Set<String> imports = fields.stream()
            .map(field -> field.asType().toString())
            .map(this::extractBaseType)  // Extract base type without generics
            .filter(type -> type.contains("."))
            .collect(Collectors.toSet());
        
        for (String importType : imports) {
            writer.write("import " + importType + ";\n");
        }
        writer.write("\n");
    }

    private String extractBaseType(String fullType) {
        // Remove generic type parameters for import statements
        int genericStart = fullType.indexOf('<');
        if (genericStart > 0) {
            return fullType.substring(0, genericStart);
        }
        return fullType;
    }

    private void writeField(Writer writer, VariableElement field) throws IOException {
        // Write field with its type and name
        String type = field.asType().toString();
        String name = field.getSimpleName().toString();
        writer.write("    private " + type + " " + name + ";\n\n");
    }

    private void writeAccessors(Writer writer, VariableElement field) throws IOException {
        String type = field.asType().toString();
        String name = field.getSimpleName().toString();
        String capitalizedName = name.substring(0, 1).toUpperCase() + name.substring(1);
        
        // Getter
        writer.write("    public " + type + " get" + capitalizedName + "() {\n");
        writer.write("        return " + name + ";\n");
        writer.write(STRING_END);
        
        // Setter
        writer.write("    public void set" + capitalizedName + "(" + type + " " + name + ") {\n");
        writer.write("        this." + name + " = " + name + ";\n");
        writer.write(STRING_END);
    }

    private void writeEquals(Writer writer, List<VariableElement> fields, String className) throws IOException {
        writer.write(OVERRIDE);
        writer.write("    public boolean equals(Object o) {\n");
        writer.write("        if (this == o) return true;\n");
        writer.write("        if (o == null || getClass() != o.getClass()) return false;\n");
        writer.write("        " + className + " that = (" + className + ") o;\n");
        
        // Compare each field
        for (VariableElement field : fields) {
            String name = field.getSimpleName().toString();
            writer.write("        if (!Objects.equals(" + name + ", that." + name + ")) return false;\n");
        }
        
        writer.write("        return true;\n");
        writer.write(STRING_END);
    }

    private void writeHashCode(Writer writer, List<VariableElement> fields) throws IOException {
        writer.write(OVERRIDE);
        writer.write("    public int hashCode() {\n");
        writer.write("        return Objects.hash(");
        
        // Add all fields to hash
        boolean first = true;
        for (VariableElement field : fields) {
            if (!first) {
                writer.write(", ");
            }
            writer.write(field.getSimpleName().toString());
            first = false;
        }
        
        writer.write(");\n");
        writer.write(STRING_END);
    }

    private void writeToString(Writer writer, List<VariableElement> fields) throws IOException {
        writer.write(OVERRIDE);
        writer.write("    public String toString() {\n");
        writer.write("        return \"" + dtoClassName + "{\" +\n");
        
        // Add all fields to string representation
        boolean first = true;
        for (VariableElement field : fields) {
            String name = field.getSimpleName().toString();
            if (first) {
                writer.write("            \"" + name + "=\" + " + name);
                first = false;
            } else {
                writer.write(" +\n            \", " + name + "=\" + " + name);
            }
        }
        
        writer.write(" +\n            \"}\";\n");
        writer.write(STRING_END);
    }
}
