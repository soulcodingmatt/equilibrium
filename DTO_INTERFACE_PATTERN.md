# DTO Interface Implementation Pattern

## üìã Problem Statement

DTOs often need to implement interfaces like `Serializable`, `Comparable`, or custom business interfaces. However, generating interface implementations automatically leads to several issues:

- **Generic implementations are often useless** (e.g., `compareTo()` using `toString()`)
- **Different interfaces require specific business logic** that can't be generated generically
- **Loss of developer control** over important business behavior
- **Mixing concerns** - DTOs should remain pure data containers

## üéØ Solution: Clean Separation Pattern

Instead of generating interface implementations directly in DTOs, use a **two-layer approach**:

1. **Equilibrium generates pure DTOs** (no interface implementations)
2. **Developers create manual wrapper classes** for interface implementations

## üöÄ Implementation

### Step 1: Generate Pure DTO with Equilibrium

```java
@GenerateDto
public class Bird {
    private String species;
    private boolean canFly;
    private int wingspan;
}
```

**Generated Result:**
```java
/**
 * DTO for {@link Bird}
 * Generated by Equilibrium
 */
public class BirdDto {
    private String species;
    private boolean canFly;
    private int wingspan;

    // Standard getters, setters, equals, hashCode, toString
    public String getSpecies() { return species; }
    public void setSpecies(String species) { this.species = species; }
    // ... etc
}
```

### Step 2: Create Manual Interface Wrapper

```java
// Your custom wrapper class in the using project
public class ComparableBird implements Comparable<ComparableBird>, Serializable {
    
    private static final long serialVersionUID = 1L;
    private final BirdDto dto;
    
    public ComparableBird(BirdDto dto) {
        this.dto = dto;
    }
    
    // Delegate methods you need
    public String getSpecies() { return dto.getSpecies(); }
    public boolean getCanFly() { return dto.getCanFly(); }
    public int getWingspan() { return dto.getWingspan(); }
    
    // Your custom interface implementations
    @Override
    public int compareTo(ComparableBird other) {
        // Custom business logic for comparison
        int speciesComparison = this.getSpecies().compareTo(other.getSpecies());
        if (speciesComparison != 0) return speciesComparison;
        
        return Integer.compare(this.getWingspan(), other.getWingspan());
    }
    
    @Override
    public String toString() {
        return String.format("ComparableBird{species='%s', wingspan=%d}", 
                           getSpecies(), getWingspan());
    }
}
```

## üìù Usage Examples

### Basic Usage
```java
// Create DTO
BirdDto dto = new BirdDto();
dto.setSpecies("Eagle");
dto.setWingspan(220);

// Use directly as DTO
saveBird(dto);

// Wrap for interface functionality
ComparableBird bird = new ComparableBird(dto);
Collections.sort(birdList); // Works with your custom compareTo
```

### Multiple Interface Implementations
```java
// Different wrappers for different use cases
public class SerializableBird implements Serializable {
    private final BirdDto dto;
    // Implementation for serialization needs
}

public class ValidatableBird implements Validatable {
    private final BirdDto dto;
    // Implementation for validation needs
}

public class FullFeaturedBird implements Comparable<FullFeaturedBird>, 
                                          Serializable, 
                                          Validatable {
    private final BirdDto dto;
    // Combined implementation
}
```

### Builder Pattern Integration
```java
@GenerateDto(builder = true)
public class Bird {
    private String species;
    private boolean canFly;
}

// Usage with builder
BirdDto dto = BirdDto.builder()
    .species("Falcon")
    .canFly(true)
    .build();
    
ComparableBird bird = new ComparableBird(dto);
```

## üéØ Best Practices

### 1. **Composition over Inheritance**
```java
// ‚úÖ Good: Composition
public class ComparableBird implements Comparable<ComparableBird> {
    private final BirdDto dto;  // Composition
}

// ‚ùå Avoid: Inheritance (harder to maintain)
public class ComparableBird extends BirdDto implements Comparable<ComparableBird> {
    // Inheritance creates tight coupling
}
```

### 2. **Delegate Only What You Need**
```java
public class ComparableBird implements Comparable<ComparableBird> {
    private final BirdDto dto;
    
    // Only expose methods you actually need
    public String getSpecies() { return dto.getSpecies(); }
    public int getWingspan() { return dto.getWingspan(); }
    
    // Don't expose everything blindly
    // public boolean getCanFly() { ... } // Only if needed
}
```

### 3. **Meaningful Interface Implementations**
```java
@Override
public int compareTo(ComparableBird other) {
    // ‚úÖ Business-meaningful comparison
    if (!this.getSpecies().equals(other.getSpecies())) {
        return this.getSpecies().compareTo(other.getSpecies());
    }
    return Integer.compare(this.getWingspan(), other.getWingspan());
    
    // ‚ùå Avoid generic implementations
    // return this.toString().compareTo(other.toString());
}
```

### 4. **Consistent Naming**
```java
// Pattern: [Purpose][EntityName]
public class ComparableBird implements Comparable<ComparableBird> { }
public class SerializableBird implements Serializable { }
public class ValidatableBird implements Validatable { }

// Or: [EntityName][Purpose]  
public class BirdComparator implements Comparable<BirdComparator> { }
public class BirdSerializer implements Serializable { }
```

## ‚úÖ Benefits

| Aspect | Benefit |
|--------|---------|
| **Separation of Concerns** | DTOs remain pure data containers |
| **Developer Control** | Full control over interface implementations |
| **Business Logic** | Meaningful implementations instead of generic ones |
| **Flexibility** | Different wrappers for different use cases |
| **Maintainability** | Clear separation between data and behavior |
| **Testability** | Interface logic can be tested separately |
| **IDE Support** | Full autocomplete and refactoring support |
| **Type Safety** | Compile-time interface validation |

## üîÑ Migration from Auto-Generated Interfaces

If you previously used auto-generated interface implementations:

### Before (Auto-Generated)
```java
@GenerateDto(interfaces = {"Comparable<BirdDto>"})
public class Bird { }

// Generated generic compareTo - often useless
public int compareTo(BirdDto other) {
    return this.toString().compareTo(other.toString());
}
```

### After (Manual Wrapper)
```java
@GenerateDto  // Clean DTO only
public class Bird { }

// Your meaningful implementation
public class ComparableBird implements Comparable<ComparableBird> {
    public int compareTo(ComparableBird other) {
        // Your business logic here
    }
}
```

## üéâ Conclusion

This pattern provides the **best of both worlds**:
- **Fast DTO generation** with Equilibrium
- **Full control** over interface implementations
- **Clean separation** of data and behavior
- **Meaningful business logic** instead of generic implementations

The result is **maintainable, testable, and business-focused code** that scales well with your application's needs. 