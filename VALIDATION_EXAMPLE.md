# Jakarta Bean Validation Integration

## Overview

The `@ValidateDto` annotation allows you to add Jakarta Bean Validation annotations to fields in your generated DTO classes with **compile-time type safety**. This provides automatic validation capabilities for your DTOs without manually writing them.

## Type-Safe Usage (Recommended)

### Domain Class with Type-Safe Validation

```java
import io.github.soulcodingmatt.equilibrium.annotations.dto.GenerateDto;
import io.github.soulcodingmatt.equilibrium.annotations.dto.ValidateDto;
import io.github.soulcodingmatt.equilibrium.annotations.dto.validation.*;

@GenerateDto
public class Person {
    
    @ValidateDto(
        notNull = @NotNullValidation(message = "Name cannot be null"),
        notBlank = @NotBlankValidation(message = "Name cannot be blank"),
        size = @SizeValidation(min = 2, max = 50, message = "Name must be between 2 and 50 characters")
    )
    private String name;
    
    @ValidateDto(
        notNull = @NotNullValidation(message = "Age cannot be null"),
        min = @MinValidation(value = 0, message = "Age must be at least 0"),
        max = @MaxValidation(value = 150, message = "Age must be at most 150")
    )
    private Integer age;
    
    @ValidateDto(
        email = @EmailValidation(message = "Invalid email format"),
        notBlank = @NotBlankValidation(message = "Email cannot be blank")
    )
    private String email;
    
    // ... getters and setters
}
```

### Benefits of Type-Safe Approach

✅ **Compile-time validation** - Syntax errors caught at compile time  
✅ **IDE autocomplete** - Full IntelliJ/Eclipse autocomplete support  
✅ **Type safety** - No string-based configuration that can break silently  
✅ **Refactoring support** - IDE can safely rename and refactor validation parameters

### Generated PersonDto

The annotation processor will generate the following DTO:

```java
package your.dto.package;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Email;
import java.util.Objects;

/**
 * DTO for {@link your.domain.package.Person}
 * Generated by Equilibrium
 */
public class PersonDto {

    @NotNull(message = "Name cannot be null")
    @NotBlank(message = "Name cannot be blank")
    @Size(min = 2, max = 50, message = "Name must be between 2 and 50 characters")
    private String name;

    @NotNull(message = "Age cannot be null")
    @Min(value = 0, message = "Age must be at least 0")
    @Max(value = 150, message = "Age must be at most 150")
    private Integer age;

    @Email(message = "Invalid email format")
    @NotBlank(message = "Email cannot be blank")
    private String email;

    // Getters and setters...
    // equals(), hashCode(), toString() methods...
}
```

## Advanced Usage: ID-Based Validation

For multiple DTOs with different validation requirements:

### Domain Class with Multiple DTOs

```java
@GenerateDtos({
    @GenerateDto(id = 1, postfix = "CreateDto"),
    @GenerateDto(id = 2, postfix = "UpdateDto"), 
    @GenerateDto(id = 3, postfix = "ViewDto")
})
public class User {
    
    // Username validation only for creation and updates
    @ValidateDto(
        notNull = @NotNullValidation(message = "Username cannot be null"),
        notBlank = @NotBlankValidation(message = "Username cannot be blank"),
        size = @SizeValidation(min = 3, max = 20, message = "Username must be between 3 and 20 characters"),
        pattern = @PatternValidation(regexp = "^[a-zA-Z0-9_]+$", message = "Username can only contain letters, numbers, and underscores"),
        ids = {1, 2} // Only for CreateDto and UpdateDto
    )
    private String username;
    
    // Password validation only for creation
    @ValidateDto(
        notNull = @NotNullValidation(message = "Password cannot be null"),
        notBlank = @NotBlankValidation(message = "Password cannot be blank"),
        size = @SizeValidation(min = 8, max = 100, message = "Password must be between 8 and 100 characters"),
        ids = {1} // Only for CreateDto
    )
    private String password;
    
    // Age validation for all DTOs (no ids = applies to all)
    @ValidateDto(
        min = @MinValidation(value = 13, message = "User must be at least 13 years old"),
        max = @MaxValidation(value = 120, message = "Age must be realistic")
    )
    private Integer age;
    
    // ... other fields and methods
}
```

### Generated DTOs

#### UserCreateDto (id = 1)
```java
public class UserCreateDto {
    @NotNull(message = "Username cannot be null")
    @NotBlank(message = "Username cannot be blank") 
    @Size(min = 3, max = 20, message = "Username must be between 3 and 20 characters")
    private String username;

    @NotNull(message = "Password cannot be null")
    @Size(min = 8, max = 100, message = "Password must be between 8 and 100 characters")
    private String password;

    @Min(value = 13, message = "User must be at least 13 years old")
    private Integer age;
    
    // ... methods
}
```

#### UserUpdateDto (id = 2)
```java
public class UserUpdateDto {
    @NotNull(message = "Username cannot be null")
    @NotBlank(message = "Username cannot be blank")
    @Size(min = 3, max = 20, message = "Username must be between 3 and 20 characters")
    private String username;

    // No password validation for updates
    private String password;

    @Min(value = 13, message = "User must be at least 13 years old")
    private Integer age;
    
    // ... methods
}
```

#### UserViewDto (id = 3)
```java
public class UserViewDto {
    // No username validation for view
    private String username;

    // No password validation for view
    private String password;

    @Min(value = 13, message = "User must be at least 13 years old")
    private Integer age;
    
    // ... methods
}
```

## Supported Jakarta Bean Validation Annotations

The following Jakarta Bean Validation annotations are automatically imported when used:

### Null Constraints
- `@NotNull`
- `@NotEmpty` 
- `@NotBlank`

### Size Constraints  
- `@Size`
- `@Min`
- `@Max`
- `@DecimalMin`
- `@DecimalMax`
- `@Positive`
- `@PositiveOrZero`
- `@Negative`
- `@NegativeOrZero`
- `@Digits`

### Format Constraints
- `@Email`
- `@Pattern`

### Date/Time Constraints
- `@Future`
- `@FutureOrPresent`
- `@Past`
- `@PastOrPresent`

### Boolean Constraints
- `@AssertTrue`
- `@AssertFalse`

### Validation
- `@Valid`

## Tips for IDE Autocomplete

To get autocomplete support in your IDE:

1. **Add Jakarta Bean Validation dependency** to your project:
   ```xml
   <dependency>
       <groupId>jakarta.validation</groupId>
       <artifactId>jakarta.validation-api</artifactId>
       <version>3.0.2</version>
   </dependency>
   ```

2. **Use string literals** with proper escaping for complex patterns:
   ```java
   @ValidateDto({
       "@Pattern(regexp = \"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\", message = \"Invalid email\")"
   })
   ```

3. **IDE templates** can help with common validation patterns:
   - Create live templates for frequently used validation combinations
   - Use code snippets for complex regex patterns

## Legacy String-Based Approach (Deprecated)

For backward compatibility, the old string-based approach is still supported but deprecated:

```java
@ValidateDto(value = {
    "@NotNull(message = \"Name cannot be null\")",
    "@Size(min = 2, max = 50, message = \"Name must be between 2 and 50 characters\")"
})
private String name;
```

**⚠️ Issues with string-based approach:**
- No compile-time validation
- Easy to make syntax errors
- No IDE autocomplete
- Harder to refactor

**Migration:** Replace `value = { "..." }` with type-safe parameters like `notNull = @NotNull(...)`.

## Available Type-Safe Validation Annotations

| Type-Safe Parameter | Generated Jakarta Annotation | Example |
|---------------------|-------------------------------|---------|
| `notNull` | `@NotNull` | `notNull = @NotNull(message = "Required")` |
| `notBlank` | `@NotBlank` | `notBlank = @NotBlank(message = "Cannot be blank")` |
| `size` | `@Size` | `size = @Size(min = 2, max = 50)` |
| `min` | `@Min` | `min = @Min(value = 18)` |
| `max` | `@Max` | `max = @Max(value = 120)` |
| `email` | `@Email` | `email = @Email(message = "Invalid email")` |
| `pattern` | `@Pattern` | `pattern = @Pattern(regexp = "^[A-Z]+$")` |

## Error Handling

- Type-safe validations are validated at compile time
- Invalid parameter values result in compilation errors
- Missing `ids` array means validation applies to all generated DTOs
- Invalid `ids` are ignored (validation won't be applied to non-existent DTOs)
- Legacy string validations: malformed strings cause compilation errors in generated DTOs 